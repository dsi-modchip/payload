
#include <stddef.h>
#include <stdint.h>
#include <stdbool.h>

#include <dawn/hw/arm.h>
#include <dawn/hw/gpio.h>
#include <dawn/hw/i2c.h>
#include <dawn/hw/memory.h>
#include <dawn/hw/spi.h>


inline static char hex2nyb(uint8_t v) {
	v &= 0xf;
	if (v < 0xa) v = v - 0 + '0';
	else v = v - 0xa + 'a';
	return v;
}


__attribute__((__always_inline__))
inline static void bios_memcpy(const void* src, volatile void* dst, size_t len) {
	void (*bios_memcpy_fptr)(const void*, volatile void*, size_t) = 0x10e0;
	bios_memcpy_fptr(src, dst, len);
}


void swi_wait_by_loop(int32_t count);
__attribute__((__target__("arm"), __naked__))
void swi_wait_by_loop(int32_t count) {
	(void)count;
	asm volatile(
		"swi 0x030000\n"
		"bx lr\n"
		:::"r0"
	);
}

static inline void i2c_write(uint8_t dev, uint8_t reg, uint8_t data) {
	i2c_write_blocking(dev, reg, 1, &data);
}


static void spi_send(const void* payload, size_t len_bytes) {
	const uint8_t* pl = payload;

	uint8_t pfix[2] = {0x05, 'P'};
	spi_transfer_blocking(&REG_SPI_HW, 1, true , sizeof(pfix), pfix, NULL);
	spi_transfer_blocking(&REG_SPI_HW, 1, false, len_bytes, payload, NULL);
}
static void spi_print(const char* s) {
	size_t l = 0;
	const uint8_t* pl = s;
	for (; *s; ++s, ++l) COMPILER_BARRIER(); // compiler inserts a call to strlen here

	spi_send(pl, l);
}
static void spi_hexdump(const void* data, size_t size) {
	// do it in chunks of 4 bytes because bus size bs
	char bleh[12+1];
	bleh[12] = 0;
	for (size_t i = 0; i < size; i += 4) {
		uint32_t v = ((const uint32_t*)data)[i>>2];
		bleh[ 0] = hex2nyb(v>> 4);
		bleh[ 1] = hex2nyb(v>> 0);
		bleh[ 2] = ' ';
		bleh[ 3] = hex2nyb(v>>12);
		bleh[ 4] = hex2nyb(v>> 8);
		bleh[ 5] = ' ';
		bleh[ 6] = hex2nyb(v>>20);
		bleh[ 7] = hex2nyb(v>>16);
		bleh[ 8] = ' ';
		bleh[ 9] = hex2nyb(v>>28);
		bleh[10] = hex2nyb(v>>24);
		bleh[11] = ' ';

		size_t todo = 12;
		if (size - i < 4) {
			todo = 3*(size - i);
			bleh[todo] = 0;
		}
		spi_send(bleh, todo);

		if (((i + 4) & 0xf) == 0 || size - i <= 4) { // split at line, *or* final one to do
			spi_send("\r\n", 2);
		}
	}
}


static void gpio_init(void) {
	gpio_set_irq_edge_all(0xff);
	gpio_set_irq_all(0);
	gpio_put_all(twl_gpio_330_msk|twl_gpio_mute_msk);
	gpio_set_dir_all_bits(0x90/*gpio330,mute output*/);
}

static inline void gpio_write_330(bool value) {
	gpio_put(twl_gpio_330, value);
}


__attribute__((__used__, __externally_visible__, __noreturn__))
int main(void) {
	void (*ipc_notifyID)(int id) = 0x55f8|1;
	uint32_t (*ipc_notifyrecv)(void) = 0x5608|1;

	ipc_notifyID(42);

	spi_print("*hacker voice* im in\r\n");
	gpio_init();
	gpio_write_330(false);
	swi_wait_by_loop(0x20ba/10);
	gpio_write_330(true);
	swi_wait_by_loop(0x20ba/10);
	gpio_write_330(false);

	// NOTE: this hangs sometimes. so only notify the glitch controller AFTER
	//       this has succeeded (FIXME why does it hang??)
	while (!(REG_EXMEMSTAT & 0x4000)) asm volatile("":::"memory");
	spi_print("fcram inited\r\n");

	const uint8_t v[] = {0x05,0x13,0x37,0x42};
	spi_transfer_blocking(&REG_SPI_HW, 1, false, sizeof(v), v, NULL);

	while (ipc_notifyrecv() != 43) asm volatile("":::"memory");
	i2c_write(0x4a, 0x31, 1); // set camled high

	bios_memcpy((const void*)0x0000, (void*)0x02010000, 0x10000);
	spi_print("magic:\r\n");
	spi_hexdump((const void*)0x02020000, 0x10);
	spi_print("ARM9i:\r\n");
	spi_hexdump((const void*)0x02008000, 0x20);
	spi_print("ARM7i:\r\n");
	spi_hexdump((const void*)0x02018000, 0x20);

	i2c_write(0x4a, 0x31, 0); // set camled low again (doesn't get reset by BPTWL)

	// TODO: draw the rest of the fucking owl

	while(1);
	__builtin_unreachable();
}

